**浏览器**： 1个浏览器主进程（页面的展示、数据存储）、1个gpu进程（页面的绘制）、1个网络进程（网络资源的加载）、多个渲染进程（html\css\js的页面交互）、多个插件进程



*只要一个线程崩溃、就会导致整个进程崩溃*



*多个进程之间是通过IPC（跨进程）机制去通信的。多个线程是可以相互共享数据的，可以对进程的公共数据进行读写操作*



**单进程**： 缺点： 不稳定（插件、渲染模块都很容易导致浏览器的崩溃）、不安全（通过插件恶意控制你的代码）、不流畅（如果一个线程执行，其他的线程就会被阻塞，页面会卡顿）



**多进程**： 进程之间是相互独立的， 一个进程的卡顿，奔溃并不会影响其他进程。而且多进程中好处就是可以使用安全沙箱，沙箱里面的程序可以运行、但是不能往硬盘里面修改数据。相当于给进程上了一层锁。保护数据的安全。

*但内存不足的情况下，一些进程会纳入到浏览器主进程中。*



***从用户输入地址，浏览器的整个过程：***

*1、用户输入地址、会检查一下是否有缓存，没有？DNS解析地址找到对应的ip地址： 否则直接连接对应ip地址，（如果请求协议是HTTPS，那么还需要建立TLS连接。）接下来就是进行tcp链接。*

*2、请求资源，开始3次握手（1、客户端发起连接请求， 2、服务端接到连接请求，并发送已接收到连接请求，是否确认连接。3、发起确认连接请求，服务端收到消息，并确认开启）、*

 *四次挥手。（1、客户端发起结束请求 2、服务端发出收到结束请求，请稍等 2、服务端发出确认结束的请求 3、客户端收到已结束的请求回复，请求已结束）*

*3、获取文档，根据文档类型 决定使用什么脚本去解析文档、从上往下执行。解析html\css\js。*

*4、渲染页面*

​	1-1、渲染进程将html转换成浏览器可解析的dom结构

##### 	1-2、渲染引擎将css解析成可解析的stylesheets, 并计算出每个dom对应的样式

​	1-3、绘制布局树，计算dom的布局信息

​	1-4、根据布局树进行分层、组成分层树、

​	1-5、将每个图层形成一个绘制列表、并发送给合成线程

​	1-6、合成线程将图层拆分成图块，进行光栅格化将图块生成位图

​	1-7、合成线程发送绘制图块 指令给浏览器进程

​	1-8、浏览器进行绘制、显示。并保存在内存中



**变量提升：函数变量提升 》变量提升**

出现同一个名字的函数、变量，会被后面的函数、变量覆盖。

执行一段javascript代码时，会生成一个执行上下文(一个js代码执行的运行环境，-- 变量环境、词法环境== 执行一个函数，他会进入一个函数的执行上下文， 确定函数内部的this、变量、对象、函数的值)、可执行代码。



控制台 source打断点， 可以看到调用栈的顺序。更好地排查bug

也可以使用console.trace 输出调用栈的顺序



**词法作用域链**

函数中的变量，如果函数内部没有定义， 则会根据词法作用域链来获取。

词法作用域链 是函数被定义的位置决定的。而不是调用的位置决定的。明白了这个，就很容易知道一个变量获取的作用域链了。



##### **数据存储：堆栈空间**



**堆栈空间：原始数据类型存储在栈中，引用数据类型存储在堆中**

根据执行上下文栈的位置，每次生成对应的执行上下文 都会生成对应变量的一个变量环境，原始数据的就直接把值存在栈中、而引用数据类型的值 是存储 对应在堆的数据地址。所以类似执行 var a = {name: 1}, var b = a。那么a\b在栈中的值都是同一个堆的引用地址。



当执行到一个内部函数， 并且内部函数引用了外部变量时，javascript 会在栈中创建一个closure闭包对象，值 为 在堆中的数据地址。并且 内部函数使用的变量都会存在 堆中closure对象内。



在浏览器中 开发者工具 -》Memory -》点击录制快照snapshot，可以查看v8堆内存的快照



**垃圾回收策略**

javascriptd v8引擎垃圾回收机制把 堆内存 分为两种：新生代（一般存储1-8m的对象，存储小对象）-- 副垃圾回收器、老生代（存储比较大对象）--主垃圾回收器



新生代： 副垃圾回收器使用的scanvenge算法，将新生代的区域分为： 对象区域、空闲区域。

新加的对象一般都会放在 对象区域， 当对象区域满时，进行垃圾清理。标记活动的对象，并把这些活动的对象复制到空闲区域。然后并整理这些对象。此时的空闲区域 就变成了 对象区域，对象区域变成了空闲区域。这样循环更替进行垃圾清理。



新生代空间小，处理会比较频繁，如果数据量太大，很容易就满了。因此经历过两次垃圾回收还活跃的对象，会移动到老生代。（晋升策略）

老生代存储的除了大内存的对象， 还有就是长时间活跃的对象（新生代转移过来的）。老生代存储的数据比较多，所以不能按照新生代的scanvenge算法进行计算，否则会耗时很长。



老生代使用的是： 主垃圾回收器：标记-清除法。首先是标记阶段，在执行上下文的调用栈中，标记活跃的对象。当执行完一个方法之后， 会从调用栈中移除，那么对应堆内存中的数据，就可以被清除了。（从调用栈移除之后，遍历调用栈，发现没有引用堆内存的某些数据， 因此可以移除掉）

同一块内存， 多次清除，会存在垃圾内存碎片，如果进来一个大的对象的话，就出现内存不足了。因为我们还需要进行 标记-整理内存。标记完，整理活跃的对象移到边界处，边界之外的全部清理，那就不存在内存碎片了。



但因为JavaScript是执行在主线程，所以当进行垃圾回收机制的时候，只有当垃圾回收机制处理完， 才能继续执行JavaScript代码。这就是全停顿。

新生代空间小、全停顿问题不大。但是老生代空间大， 存储内存大的话，处理起来时间消耗久一些。就会造成页面卡顿， 造成体验不好。



为了优化老生代带来的这个卡顿的问题， 因此出现了一个增量标记的策略。将老生代的标记流程分成小等分，嵌套插入到JavaScript主线程中，交替进行。





**V8引擎的执行机制**

v8引擎中有两种机制：编译器、解析器

v8引擎的工作机制：将javascript代码转换成Ast、执行上下文 -》字节码 ->机器码

**如何生成AST（抽象语法树）**，**有两个步骤： 一、分词。（词法分析） 二、解析 （语法分析）**



词法分析：就是将一行javascript代码 切分成一个个的token， token就是指切分成一个最小单位的字符、字符串。

语法分析：将刚刚分割的token根据语法规则生成ast。



生成AST之后， 生成对应的执行上下文。在基于 Ast 通过解析器 转换成字节码。然后再由解析器一行行地去解释执行字节码。

如果一段代码重复次数多的话，这段代码就会标记为热代码。 这时 编译器出来了，编译这段 热代码 将字节码编译成 机器码。提高下一次的执行效率。





**浏览器的页面循环系统**

javascript代码是执行在主线程的，增加任务只需要在主线程的消息队列里面增加一个任务。即使是其他渲染进程、javascript进程需要给主线程增加任务的时候，也是直接往消息队列里面增加任务。

当代码中使用了setTimeout的时候，就是会延迟一段时间再执行一个函数。那么如果把这个任务增加到消息队列的话，那怎么根据延迟的时间去执行对应地任务呢？ 显然放在消息队列是不行的，我们需要另一个队列，就是延迟队列，放置一些需要延迟执行的任务。每当执行完了一个消息队列的任务，就会去延迟队列里面看看 这个任务是否到时间可执行了，然后依次执行。执行了到时间的延迟队列，则进行执行消息队列 的任务。执行了一个之后，继续去延迟队列执行任务，以此循环。

**因此会存在一个问题，就是当前的任务执行时间过长的话，会影响我们定时器的任务执行的时间，不能按照正常的延迟时间去执行。**



setTimeout函数里面如果还嵌套一个函数的话，默认会有4毫秒的延迟。延迟时间小于4毫秒，就按照4毫秒的时间。否则就按照设置的时间。

我们常见的一些浏览器，**谷歌、火狐、safari，可延迟的最长时间就是32bit，就是24.8天**。如果**延迟时间超过这个最长时间，则会立即执行**，否则就可以正常地延迟执行。



**宏任务**

1、渲染事件（解析dom、计算布局、绘制）

2、用户交互事件

3、JavaScript脚本执行事件

4、网络请求交互、文本读写操作

每个宏任务都会有对应的一个微任务队列，那么微任务产生的方式有两种：

1-1、由mutationObserve监听的DOM节点的变化

1-2、由promise产生的回调promise.resolve()\reject的函数





**微任务**

1、异步回调函数产生的宏任务

2、在主函数执行之后，退出全局上下文执行的，就是微任务的一种形式？



微任务：是在主函数执行之后，退出全局上下文之前，也就是在当前宏任务结束之前，会执行所有的微任务。执行微任务过程中产生的微任务，也是会继续增加到微任务队列，一直执行、直到微任务队列执行完，才会进行下一次的宏任务执行。



